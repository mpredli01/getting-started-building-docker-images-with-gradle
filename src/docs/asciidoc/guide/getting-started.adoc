== Getting Started

In this Gradle Guide, you will learn how to build a simple Docker image using the https://github.com/bmuschko/gradle-docker-plugin[Gradle Docker Plugin].

=== What You'll Build

You will build a Java application that generates a simple `Dockerfile`, builds the Docker image and creates the container. You will be using the Gradle Docker Plugin to achieve this goal.

=== What You'll Need

* A text editor or IDE such as https://www.jetbrains.com/idea/download/[IntelliJ IDEA]
* A Java Development Kit (JDK), version 11+
* The latest version of https://www.docker.com/[Docker]
* The latest https://gradle.org/install/[Gradle] distribution
* The https://github.com/docker-java/docker-java[Docker Java] library

[IMPORTANT]
The Gradle Docker Plugin requires Gradle >= 7.4.0.

=== Create a Project Folder

Gradle comes with a built-in task, called `init`, that initializes a new Gradle project in an empty folder. The `init` task uses the (also built-in) `wrapper` task to create a Gradle wrapper script, `gradlew`.

The first step is to create a folder for the new project and change directory into it.

[source, gradle]
----
$ mkdir demo
$ cd demo
----

=== Execute the `init` Task

From inside your new project directory, run the `init` task using the following command in a terminal:

[source, gradle]
----
$ gradle init
----

When prompted, select the `2: application` project type and `3: Java` as implementation language. Afterwards, select 2: Add library projects. Next you can choose the DSL for writing buildscripts - 1 : Groovy or 2: Kotlin. For the other questions, press enter to use the default values.

[source, gradle]
----
Starting a Gradle Daemon (subsequent builds will be faster)

Select type of project to generate:
  1: basic
  2: application
  3: library
  4: Gradle plugin
Enter selection (default: basic) [1..4] 2

Select implementation language:
  1: C++
  2: Groovy
  3: Java
  4: Kotlin
  5: Scala
  6: Swift
Enter selection (default: Java) [1..6] 3

Split functionality across multiple subprojects?:
  1: no - only one application project
  2: yes - application and library projects
Enter selection (default: no - only one application project) [1..2] 1

Select build script DSL:
  1: Groovy
  2: Kotlin
Enter selection (default: Groovy) [1..2] 1

Generate build using new APIs and behavior (some features may change in the next minor release)? (default: no) [yes,

Select test framework:
  1: JUnit 4
  2: TestNG
  3: Spock
  4: JUnit Jupiter
Enter selection (default: JUnit Jupiter) [1..4] 1

Project name (default: test-application):
Source package (default: test.application): org.gradle

> Task :init
Get more help with your project: https://docs.gradle.org/7.6/samples/sample_building_java_applications.html

BUILD SUCCESSFUL in 1m 31s
2 actionable tasks: 2 executed

----

The `init` task generates the new project with the following structure:

[source, gradle]
----
.
├── app
│   ├── build.gradle
│   └── src
│       ├── main
│       │   ├── java
│       │   │   └── org
│       │   │       └── gradle
│       │   │           └── App.java
│       │   └── resources
│       └── test
│           ├── java
│           │   └── org
│           │       └── gradle
│           │           └── AppTest.java
│           └── resources
├── gradle
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradlew
├── gradlew.bat
└── settings.gradle

14 directories, 8 files
----

=== Project Files

As you can see, the `init` task provides a comprehensive project complete with a basic application, `App.java`, and corresponing test, `AppTest.java`. However, this example application will primarily focus on building upon the `build.gradle` file as we will be working with Gradle Tasks. You will learn more about Gradle Tasks later in this guide.

The generated `build.gradle` file contains:

[source, gradle]
----
plugins {
    id 'application'
    }

repositories {
    mavenCentral()
    }

dependencies {
    testImplementation 'junit:junit:4.13.2'
    implementation 'com.google.guava:guava:31.1-jre'
    }

application {
    mainClass = 'org.gradle.App'
    }
----

=== Update the `build.gradle` File

Now that you have an application structure in place, let's build upon the `build.gradle` file that was generated by `gradle init` command.

First, you will need to import the required classes, which are Gradle Tasks, and place these statements at the very top of the `build.gradle` file:

[source, gradle]
----
import com.bmuschko.gradle.docker.tasks.DockerInfo
import com.bmuschko.gradle.docker.tasks.DockerVersion

import com.bmuschko.gradle.docker.tasks.container.DockerCreateContainer
import com.bmuschko.gradle.docker.tasks.container.DockerExecContainer
import com.bmuschko.gradle.docker.tasks.container.DockerStartContainer
import com.bmuschko.gradle.docker.tasks.container.DockerStopContainer

import com.bmuschko.gradle.docker.tasks.image.Dockerfile
import com.bmuschko.gradle.docker.tasks.image.DockerBuildImage
import com.bmuschko.gradle.docker.tasks.image.DockerListImages
----

You will need to provide additional plugins for this example application. You can do so by editing the `plugins` block:

[source, gradle]
----
plugins {
    id 'java'
    id 'application'
    id 'java-gradle-plugin'
    id 'com.bmuschko.docker-java-application' version '9.1.0'
    id 'com.bmuschko.docker-remote-api' version '9.1.0'
}
----

You will also need to provide additional dependencies for this example application. You can do so by editing the `dependencies` block:

[source, gradle]
----
dependencies {
    testImplementation 'junit:junit:4.13.2'
    implementation group: 'com.bmuschko', name: 'gradle-docker-plugin', version: '6.7.0'
    implementation group: 'com.bmuschko', name: 'asciidoctorj-tabbed-code-extension', version: '0.3'
    }
----

Now that you have initially updated your `build.gradle` file, it's time to define the tasks.

include::tasks.adoc[]
